
## 继承

继承是描述类与类之间的所属关系,通过类的继承可以形成一个关系体系    
java的class是单继承不是多继承;因为子类可以继承父类的所有功能,如果有两个父类的功能名称都相同,那么子类继承后调用的方法到底是哪个类我们就不清楚

- 一个文件中可以同时声明多个类,但是最多只能有一个`public`的类,如果是`public`则必须和文件名称保持一致
- 子类拥有父类的成员变量和方法 
- 父类的成员变量非私有,子类才能直接继承

```java
public class People {
	private double weight;
	public double getWeight() {
		return weight;
	}
	public void setWeight(double weight) {
		this.weight = weight;
	}
}
class Man extends People {
}
```
#### 方法的重写
- 如果子类定义了相同的成员变量,那么子类用的是自己的,而不是父类的
- 如果子类要使用父类的成员变量,使用super关键字进行调用,格式`为super.成员变量名称`
- 如果子类定义了父类相同的方法,叫做方法的重写,当子类对象进行方法调用的时候优先调用子类的方法,如果子类中没有就回去父类中
- 如果我们子类重写父类方法的时候,使用eclipse的提示功能让系统帮我们生成重写方法的时候会出现`@Override`,是为了增强编译性的,`@Override`下的方法父类必须有,如果没有就报错
- 如果子类要使用父类的成员方法,使用`super`关键字进行调用,格式为`super.方法名称(方法参数);`
- 子类重写父类的方法,权限必须要大于等于父类,一般我们写的方法的修饰符都是`public`

```java
public class People {
	public void eat(double eat) {
		setWeight(getWeight() + eat);
	}
}
class Man extends People {
    @Override
    public void eat(double eat) {
        super.eat(eat);
        if (getWeight()>200) {
            sport();
        }
    }
}
```

## 抽象类

1. 抽象类的格式为 `public abstract class 类名 { }`
2. 抽象方法的格式为 `public abstract 返回值类型 方法名(参数);`


- 抽象类和抽象方法都需要被`abstract`修饰。抽象方法一定要定义在抽象类中。
- 抽象类不可以直接创建对象，原因：调用抽象方法没有意义。
- 只有覆盖了抽象类中所有的抽象方法后，其子类才可以创建对象。否则该子类得定义成抽象类。
- 子类重写父类的抽象方法的时候要去掉abstract关键字
- 抽象类因为需要子类去实现,所以肯定得是一个父类
- 一个方法如果没有方法体,则必须使用`abstract`进行修饰

```java
public abstract class Staff {
private int id;
public void eat(){
	System.out.println("吃饭");
}
public abstract void work();
}
```
#### 不能与abstract共存的关键字
1. **private**：私有的方法子类是无法继承到的，也不存在覆盖，而abstract 和private 一起使用修饰方法，abstract 既要子类去实现这个方法，而private 修饰子类根本无法得到父类这个方法。互相矛盾。
2. **final**:因为被fina l定义的方法不能被重写,而抽象方法需要子类去重写进行实现功能,所以矛盾
3. **static**:因为static 不用实例化可直接调用,即当前类就直接能够调用了,而abstract 需要子类实现后才能调用,所以矛盾

## 接口
1. 接口是功能的集合，同样可看做是一种数据类型，是比抽象类更为抽象的”类”。
2. 接口中只允许出现抽象方法,不能出现非抽象方法
3. 接口的源文件也是java文件,编译后的文件也是.class,所以可以把接口看作一个特殊的类


- 接口定义时需要使用interface关键字
```java
public interface 接口名 {
	抽象方法1;
	抽象方法2;
	抽象方法3;
}
```

### 接口的实现
- 一个类实现接口的格式
```java
class 类 implements 接口1,接口2 {
	重写接口中方法
}
```

- 一个类可以同时实现多个接口,但是需要将抽象方法进行实现,创建接口的时候修饰符可以省略, 系统会自动加上,但是实现的时候,就必须要添加`public`

### 接口的特点

- 接口不能创建对象
- 因为接口是供别的类去实现的,并且要实现他的抽象方法的,所以接口中方法的访问修饰符必须定义成**public**
- 接口的变量使用`public static final`修饰,如果不写默认添加
- 接口的方法为`public abstrict`,如果不写默认添加
- 子类必须重写接口中所有的抽象方法后,才能创建对象,如果子类不不能够重写所有的抽象方法,那么子类必须定义成抽象类


- **接口可以多继承** 接口中的方法都是没有实现的,所以就算有两个父接口的方法名称相同,子类实现接口的时候也不会有什么影响,重写即可,所以接口与接口之间是存在多继承的
```java
interface MyInterface1 {
	void method01();
}
interface MyInterface2 {
	void method02();
}
interface MyInterface4 extends MyInterface1,MyInterface2 {
	void method04();
}
```

### 接口的意义

- 扩展原有类的功能
- 设定了规则
- 降低耦合性

### 接口和抽象类区别

- 相同点:
 - 都位于继承的顶端,用于被其他类实现或继承;
 - 都不能直接实例化对象;
- 都包含抽象方法,其子类都必须覆写这些抽象方法;
- 区别:
 - 抽象类可以定义非抽象方法,避免子类重复实现这些方法,提高代码重用性;接口只能包含抽象方法;
 - 一个类只能继承一个直接父类(可能是抽象类),却可以实现多个接口;(接口弥补了Java的单继承)
 - 类与类之间只能是单继承(包括抽象类),接口与接口之间可以是多实现
 - 抽象类可以定义普通的成员变量,接口只能定义`public static final`的成员变量

## 多态
- 普通类多态定义的格式 `父类 变量名 = new 子类();`
- 抽象类多态定义的格式: `抽象类 变量名 = new 抽象类子类();`
- 接口多态定义的格式: `接口 变量名 = new 接口实现类();`


- 对于引用类型的一个变量通过打点能够调用什么属性和什么方法取决于变量的类型




#### 多态的特点
- 对于成员方法:编译的时候看=左边,运行的时候看=右边
 - 打点看左边，运行的时候调用子类的方法
- 对于成员变量:编译的时候看=左边,运行的时候看=左边
 - 子类重写以后仍然返回父类的变量

#### 多态的转型

- 多态的强转,也叫做多态的向下转型,将父类类型再转换为子类类型`子类类型 变量 = (子类类型) 变量名称`

- 如果强制转换的话,必须要保证变量的类型和原始类型相同,否则就会出现异常

#### instanceof关键字

使用instanceof进行判断 `对象 instanceof 类名`，返回`true`或者`false`
```java
if(a instanceof Zi){
	Zi z = (Zi) a;
}
```

## 构造方法
如果我们希望在创建对象的时候直接就能对对象的成员变量进行赋值,就需要创建构造函数,构造函数的目的就是在对象创建的时候给对象的成员变量进行赋值

```java
修饰符 构造方法名(参数列表){
}
```

- 构造方法的特点
 - 构造方法名称必须和类型保持一致。
 - 构造方法没有具体的返回值。
 - 没有返回值类型，连void都没有


- 构造方法的作用
 - 用来创建对象
 - 通过构造方法给成员变量赋值



 - 构造方法的调用 `类名 对象名 = new 构造方法(...)`
  - `Student s = new Stident();`

#### 默认构造方法

- 如果我们没有定义过构造方法,编译器会在编译的时候添加默认空参的构造方法,这就是我们之前从未定义过构造方法,而能一直使用的原因
- 如果我们定义了新的构造方法,那么编译器就不会在给我们添加空参的构造方法.


- 构造方法的细节：
 - 一个类中可以有多个构造方法，多个构造方法是以重载的形式存在的
 - 构造方法是可以被private修饰的，作用：其他程序无法创建该类的对象。

#### 子父构造方法的调用
子类创建对象的时候,会调用父类的构造方法,在子类构造方法中的第一行总有一个隐式的调用super(); 会默认去调用父类的无参的构造方法.

```java
public class Test {

	public static void main(String[] args) {
		new Zi();
	}
}

class Fu {
	int a;

	Fu() {
		System.out.println("父类构造方法" + a);
		a = 250;
	}
}

class Zi extends Fu {
	Zi() {
		System.out.println("子类构造方法" + a);
	}
}

//输出
//父类构造方法0
//子类构造方法250
```

- 构造方法本身就是初始化对象的成员变量的,父类的构造方法也是这个目的,如果不去调用,我们就不知道父类做了什么操作,所以才会隐式的去调用super();
- 子类会继承父类中的内容，所以子类在初始化时，必须先到父类中去执行父类的初始化动作。这样，才可以使用父类中的内容。















